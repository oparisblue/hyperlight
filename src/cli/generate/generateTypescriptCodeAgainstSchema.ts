import { LIBRARY_NAME, Signature } from "../../common";
import { flatTypeToTsType } from "./flatTypeToTsType";

export function generateTypescriptCodeAgainstSchema(
  schema: Signature[],
  rpcPath: string
): string {
  let result = `//
// ******* AUTOGENERATED BY ${LIBRARY_NAME.toUpperCase()} *******
//

// Fetch + encoding helpers
function rpcFetch(t:string){return async(...e:any[])=>{let r=await(await fetch("${rpcPath}?"+t,{method:"POST",body:JSON.stringify({name:t,params:e.map(c)})})).json();return a(r)}}function c(t:any):any{return t instanceof Date?{v:t.toISOString(),t:"date"}:Array.isArray(t)?{v:t.map(e=>c(e))}:typeof t=="object"&&t!=null?{v:Object.entries(t).reduce((e,[n,r])=>({...e,[n]:c(r)}),{})}:{v:t}}function a(t:any):any{let e=t.v;return t.t==="date"&&typeof e=="string"?new Date(e):Array.isArray(e)?e.map(n=>a(n)):typeof e=="object"&&e!=null?Object.entries(e).reduce((n,[r,o])=>({...n,[r]:a(o)}),{}):e}

// Generated RPC methods

`;

  for (const signature of schema) {
    const name = signature.functionName;
    const params = signature.params
      .map(({ name, type }) => `${name}: ${flatTypeToTsType(type)}`)
      .join(", ");
    const returnType = flatTypeToTsType(signature.returnType);

    if (signature.jsDoc) {
      result += "/**\n";
      for (const line of signature.jsDoc.split("\n")) {
        result += `* ${line}\n`;
      }
      result += "*/\n";
    }
    result += `export const ${name}:(${params}) => Promise<${returnType}> = rpcFetch("${name}");\n\n`;
  }

  return result;
}

// function rpcFetch(name: string): (...params: any[]) => Promise<any> {
//   return async (...params) => {
//     const fetchResult = await fetch("${rpcPath}?" + name, {
//       method: "POST",
//       body: JSON.stringify({
//         name,
//         params: params.map(wrap)
//       })
//     });

//     const jsonResult = await fetchResult.json();
//     return unwrap(jsonResult);
//   };
// }

// function wrap(params: any): any {
//   if (params instanceof Date) return { v: params.toISOString(), t: "date" };
//   if (Array.isArray(params)) return { v: params.map((item) => wrap(item)) };
//   if (typeof params === "object" && params != null) {
//     return {
//       v: Object.entries(params).reduce(
//         (acc, [key, value]) => ({ ...acc, [key]: wrap(value) }),
//         {}
//       )
//     };
//   }
//   return { v: params };
// }

// function unwrap(result: any): any {
//   const value = result.v;
//   if (result.t === "date" && typeof value === "string") return new Date(value);
//   if (Array.isArray(value)) return value.map((item) => unwrap(item));
//   if (typeof value === "object" && value != null) {
//     return Object.entries(value).reduce(
//       (acc, [key, value]) => ({ ...acc, [key]: unwrap(value) }),
//       {}
//     );
//   }
//   return value;
// }
