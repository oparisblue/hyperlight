"use strict";var w=Object.create;var d=Object.defineProperty;var A=Object.getOwnPropertyDescriptor;var S=Object.getOwnPropertyNames;var R=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var E=(e,n)=>{for(var t in n)d(e,t,{get:n[t],enumerable:!0})},T=(e,n,t,o)=>{if(n&&typeof n=="object"||typeof n=="function")for(let r of S(n))!v.call(e,r)&&r!==t&&d(e,r,{get:()=>n[r],enumerable:!(o=A(n,r))||o.enumerable});return e};var x=(e,n,t)=>(t=e!=null?w(R(e)):{},T(n||!e||!e.__esModule?d(t,"default",{value:e,enumerable:!0}):t,e)),$=e=>T(d({},"__esModule",{value:!0}),e);var J={};E(J,{default:()=>M});module.exports=$(J);var N=x(require("typescript"));var a=x(require("typescript"));function f(e,n){if(e.flags&a.default.TypeFlags.Number)return{type:"number"};if(e.flags&a.default.TypeFlags.Boolean)return{type:"boolean"};if(e.flags&a.default.TypeFlags.String)return{type:"string"};if(e.flags&a.default.TypeFlags.Null)return{type:"null"};if(e.flags&a.default.TypeFlags.Undefined)return{type:"undefined"};if(e.flags&a.default.TypeFlags.Void)return{type:"void"};if(e.isNumberLiteral())return{type:"numberLiteral",value:e.value};if(e.isStringLiteral())return{type:"stringLiteral",value:e.value};if(D(e))return{type:"booleanLiteral",value:e.intrinsicName==="true"};if(e.isUnion()){let t=[];for(let o of e.types){let r=f(o,n);if(!r)return;t.push(r)}return{type:"union",types:t}}if(j(e)){let t=f(e.resolvedTypeArguments[0],n);return t?{type:"array",itemType:t}:void 0}if(L(e))return f(e.resolvedTypeArguments[0],n);if(C(e))return{type:"date"};if(B(e)){let t=[],o=e.getSymbol()?.getDeclarations();try{for(let r of e.getProperties()){let i=r.getDeclarations()?.[0]??o?.[0];if(!i)continue;let c=f(n.getTypeAtLocation(i),n);if(!c)return;t.push([r.getName(),c])}return{type:"object",keyValuePairTypes:t}}catch{return}}}function D(e){return!!(e.flags&a.default.TypeFlags.BooleanLiteral)}function j(e){return e.getSymbol()?.name==="Array"}function L(e){return e.getSymbol()?.name==="Promise"}function C(e){return!!(e.flags&a.default.TypeFlags.Object)&&"objectFlags"in e&&e.symbol.escapedName==="Date"}function B(e){return!!(e.flags&a.default.TypeFlags.Object)&&"objectFlags"in e&&"properties"in e&&!e.isClass()&&e.getCallSignatures().length===0}var P=/^[a-zA-Z_$][a-zA-Z0-9_$]*$/;function b(e,n,t){let o=e.getTypeChecker(),r=o.getSignatureFromDeclaration(n);if(!r)return;let i=n.name?.getText();if(!i)return;let c=[];for(let p=0;p<n.parameters.length;p++){let s=n.parameters[p];if(!s.type)return;let l=f(o.getTypeFromTypeNode(s.type),o);if(!l)return;let m=s.name.getText();c.push({name:P.test(m)?m:`param${p}`,type:l})}let g=f(o.getReturnTypeOfSignature(r),o);if(g)return{functionName:i,params:c,returnType:g,jsDoc:_(n,t)}}function _(e,n){let t=n.getJSDocCommentsAndTags(e),o=[];for(let r of t)if(typeof r=="string"&&o.push(r),"tags"in r){o.push(r.comment);for(let i of r.tags??[])o.push(`@${i.tagName.text} ${i.comment??""}`)}return o.join(`
`).replaceAll("@endpoint","").trim()}var y="hyperlight";var u={Reset:"\x1B[0m",FgRed:"\x1B[31m",FgGreen:"\x1B[32m",FgYellow:"\x1B[33m",FgMagenta:"\x1B[35m",FgCyan:"\x1B[36m",FgGray:"\x1B[90m",BgRed:"\x1B[41m",BgGreen:"\x1B[42m",BgYellow:"\x1B[43m",BgMagenta:"\x1B[45m",BgCyan:"\x1B[46m",BgGray:"\x1B[100m"};var k="registerRpc",F=new Set;function M(e,n,{ts:t}){return console.log(`Applying the ${y} magic...`),o=>{let r=o.factory;return i=>{let c=i.fileName,g=s=>{let l=O(s,e,c,t);if(!l)return t.isFunctionDeclaration(s)||t.isClassDeclaration(s)||t.isVariableDeclaration(s)?s:t.visitEachChild(s,g,o);let m=r.createCallExpression(Y(r),void 0,[r.createIdentifier(l.functionName),r.createStringLiteral(JSON.stringify(l))]),h=r.createNodeArray([s,m,r.createToken(N.default.SyntaxKind.SemicolonToken)]);return F.add(l.functionName),h};return t.visitNode(i,g)}}}function O(e,n,t,o){if(!o.isFunctionDeclaration(e)||!G(e,o))return;let r=e.name?.getText(),i=b(n,e,o);if(!i){console.log(`${u.BgRed}${t}#${r}${u.Reset}
  couldn't parse signature; ${u.FgYellow}skipped${u.Reset}
  make sure the arguments and return value are serialisable (contain no functions, classes or recursive structures)

`);return}if(F.has(i.functionName)){console.log(`${u.BgRed}${t}#${r}${u.Reset}
  duplicate endpoint name; ${u.FgYellow}skipped${u.Reset}
  make sure your endpoint names are unique across the project in their function definitions, not just in export aliases

`);return}return i}function G(e,n){return n.getJSDocTags(e).some(o=>o.tagName.text==="endpoint")}function Y(e){return e.createPropertyAccessExpression(e.createCallExpression(e.createIdentifier("require"),void 0,[e.createStringLiteral(y)]),e.createIdentifier(k))}
